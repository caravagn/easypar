mobster:::.setup_parallel
cores=3
ncores=2331
pio::pioStr(
paste0('Registering to use', cores, 'cores out of', ncores, ' ... '),
""
)
pio::pioStr(
paste0('Registering to use ', cores, ' cores out of ', ncores, ' ... '),
""
)
pio::pioStr(
paste0('Registering to use multicores ... '),
paste0(cores,' / ', ncores)
)
cores.ratio = .9
pio::pioStr(
paste0('Registering to use multicores ... '),
paste0(cores,' / ', ncores, '[ratio ', cores.ratio, ']')
)
pio::pioStr(
paste0('Registering to use multicores ... '),
paste0(cores,' / ', ncores, ' [ratio ', cores.ratio, ']')
)
pio::pioStr
cat(bgGreen(" OK\n"))
require(parallel)
require(doParallel)
require(crayon)
cat(bgGreen(" OK\n"))
cat(bgGreen(" OK \n"))
mobster::mobster_bootstrap
pio::pioDisp
pio::pioStr
message("[easypar] overriding parallel setup with global option")
opt_parallel = getOption("easypar.parallel", default = NA)
message("[easypar] overriding parallel setup with global option:", opt_parallel)
message("[easypar] overriding parallel setup", parallel, "with global option :", opt_parallel)
parallel = TRUE
message("[easypar] overriding parallel setup", parallel, "with global option :", opt_parallel)
message("[easypar] overriding parallel setup ", parallel, " with global option :", opt_parallel)
message("[easypar] overriding parallel setup [", parallel, "] with global option :", opt_parallel)
mobster:::.stop_parallel
pio::pioStr("Stopping parallel clusters: ", '')
stopCluster
if(!silent) pio::pioStr("Stopping parallel clusters ... ", '')
parallel::stopCluster(cl)
if(!silent) cat(bgGreen(" OK \n"))
f = function(x) {print(x)}
f(3)
do.call(f, list(34))
do.call(f, list(34, 88))
do.call(f, list(34, 88))
f = function(x, y) {print(x, y)}
f(3)
do.call(f, list(34, 88))
f = function(x, y) {print(paste(x, y))}
do.call(f, list(34, 88))
f = function(x, y) {print(paste(x,'ss', y))}
do.call(f, list(34, 88))
f = function(x, y) {return(paste(x,'ss', y))}
f(3,3)
do.call(f, list(34, 88))
f = function(x, y) {return(x+y)}
do.call(f, list(34, 88))
mobster::mobster_fit
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
setwd("~/Documents/GitHub/easypar")
devtools::document()
library(easypar)
??run
easypar::run
?easypar
??easypar
devtools::document()
devtools::document()
library(easypar)
?easypar
??easypar
devtools::document()
library(easypar)
??easypar
devtools::document()
library(easypar)
??easypar
sleep(3)
Sys.sleep(3)
Sys.sleep(3 * runif(1))
f = function(x) {
Sys.sleep(3 * runif(1))
print(x)
return(runif())
}
f(3)
f = function(x) {
Sys.sleep(3 * runif(1))
print(x)
return(runif(1))
}
f(3)
f = function(x) {
Sys.sleep(3 * runif(1))
cat("Input", x, '\n')
return(runif(1))
}
f(3)
list(1:5)
Reduce(append, 1:5)
Reduce(list, 1:5)
list(list(4), list(5))
append(list(4), list(5))
easypar::run(
f,
append(list(4), list(5))
)
easypar::run(
FUN = f,
PARAMS = append(list(4), list(5)),
parallel = FALSE
)
PARAMS = append(list(4), list(5))
PARAMS
PARAMS[[1]]
PARAMS
easypar::run(
FUN = f,
PARAMS = append(list(list(4)), list(list(5))),
parallel = FALSE
)
easypar::run(
FUN = f,
PARAMS = append(list(list(4)), list(list(5))),
parallel = TRUE
)
devtools::document()
library(easypar)
easypar::run(
FUN = f,
PARAMS = append(list(list(4)), list(list(5))),
parallel = TRUE
)
easypar::run(
FUN = f,
PARAMS = append(list(list(4)), list(list(5))),
parallel = TRUE,
outfile = NULL
)
easypar::run(
FUN = f,
PARAMS = append(list(list(4)), list(list(5))),
parallel = TRUE,
outfile = NULL
)
easypar::run(
FUN = f,
PARAMS = append(list(list(4)), list(list(5))),
parallel = TRUE,
outfile = "A.log"
)
easypar::run(
FUN = f,
PARAMS = append(list(list(4)), list(list(5))),
parallel = TRUE,
outfile = ""
)
easypar::run(
FUN = f,
PARAMS = append(list(list(4)), list(list(5))),
parallel = TRUE,
outfile = NA
)
# Run in parallel, no output
easypar::run(FUN = f, PARAMS = all.inputs, parallel = TRUE, outfile = NA)
inputs1 = list(4)
inputs2 = list(5)
inputs3 = list(6)
all.inputs = append(
list(inputs1),
list(inputs2),
list(inputs3)
)
inputs1 = list(4)
inputs2 = list(5)
inputs3 = list(6)
all.inputs = append(
list(inputs1),
list(inputs2),
list(inputs3)
)
# 4 inputs
inputs = runif(4)
inputs
lapply(runif(4), list)
# 4 inputs
inputs = lapply(runif(4), list)
# Run in parallel, no output
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA)
# Run sequentially, no output
easypar::run(FUN = f, PARAMS = all.inputs, parallel = TRUE, outfile = '')
# Run sequentially, no output
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = '')
# A dummy function
f = function(x)
{
Sys.sleep(5 * runif(1))
print(paste("Input", x))
return(runif(1))
}
f(3)
# A dummy function
f = function(x)
{
print(paste("Before sleep", x))
Sys.sleep(5 * runif(1))
print(paste("After sleep", x))
return(x)
}
f(3)
# A dummy function
f = function(x)
{
clock = 5 * runif(1)
print(paste("Before sleep", x, " - clock", clock))
Sys.sleep()
print(paste("After sleep", x))
return(x)
}
f(3)
# A dummy function: sleeps for some random time and then
# print the output
f = function(x)
{
clock = 5 * runif(1)
print(paste("Before sleep", x, " - clock", clock))
Sys.sleep(clock)
print(paste("After sleep", x))
return(x)
}
# A dummy function: sleeps for some random time and then
# print the output
f = function(x)
{
clock = 5 * runif(1)
print(paste("Before sleep", x, " - clock", clock))
Sys.sleep(clock)
print(paste("After sleep", x))
return(x)
}
f(3)
# A dummy function: sleeps for some random time and then
# print the output
f = function(x)
{
clock = 5 * runif(1)
print(paste("Before sleep", x, " - sleeping for ", clock))
Sys.sleep(clock)
print(paste("After sleep", x))
return(x)
}
# A dummy function: sleeps for some random time and then
# print the output
f = function(x)
{
clock = 5 * runif(1)
print(paste("Before sleep", x, " - siesta for ", clock))
Sys.sleep(clock)
print(paste("After sleep", x))
return(x)
}
f(3)
# 4 inputs (random univariate numbers)
inputs = lapply(runif(4), list)
# Run in parallel, no output
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA)
# 4 inputs (random univariate numbers)
inputs = lapply(runif(4), list)
print(inputs)
# Run in parallel, no output
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA)
# Run sequentially, output to screen
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = '')
# Run sequentially, output to screen
easypar::run(FUN = f, PARAMS = inputs, parallel = FALSE, outfile = '')
# Run sequentially, output to screen
easypar::run(FUN = f, PARAMS = inputs, parallel = FALSE, outfile = '')
library(easypar)
# Run in parallel, no output
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA)
library(easypar)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA)
# Run in parallel, no output but cacheing computations
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA, cache = "My_task.RDS")
library(easypar)
# Run in parallel, no output but cacheing computations
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA, cache = "My_task.rds")
# check the cache
readRDS("My_task.rds")
# Run parallel, output to screen (asynchronous per thread)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = '')
library(easypar)
# Run parallel, output to screen (asynchronous per thread)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = '')
# Run parallel, output to screen (asynchronous per thread)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = '')
# Run in parallel, no output but cacheing computations
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA, cache = "My_task.rds")
# Run parallel, output to screen (asynchronous per thread)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = '')
library(easypar)
# Run parallel, output to screen (asynchronous per thread)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = '')
# Run in parallel, no output but cacheing computations
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA, cache = "My_task.rds")
# Run parallel, output to screen (asynchronous per thread)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = '')
# Run sequentially, output to screen
easypar::run(FUN = f, PARAMS = inputs, parallel = FALSE, outfile = '')
# We have plugged in our tool a very complex function "f" which we call
# via easypar::run(FUN = f, PARAMS = inputs), but now we want to debug
# the runtime execution of f. The tool calls the execution with parallel
# set to TRUE, we just use the global option to force it to run without
# parallelism
options(easypar.parallel = FALSE)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE)
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA)
# A dummy function: sleeps for some random time and then
# print the output
f = function(x)
{
clock = 5 * runif(1)
print(paste("Before sleep", x, " - siesta for ", clock))
Sys.sleep(clock)
print(paste("After sleep", x))
return(x)
}
f(3)
inputs = lapply(runif(4), list)
print(inputs)
# Run in parallel, no output
easypar::run(FUN = f, PARAMS = inputs, parallel = TRUE, outfile = NA)
library(easypar)
library(easypar)
library(easypar)
